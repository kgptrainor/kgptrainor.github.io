---
layout: post
title:  "K8S - Commands"
date:   2024-03-04 12:13:26 +0000
categories: AWS EKS
---

## Background 

Contour is an open source Kubernetes ingress controller that works by deploying the Envoy proxy as a reverse proxy and load balancer.

## Contour Service (ClusterIP):

- **Type:** ClusterIP
- **ClusterIP:** 10.100.238.213
- **External-IP:** `<none>` (This is an internal ClusterIP service, not exposed externally.)
- **Ports:** 8001/TCP
- **Purpose:** The `contour` service provides access to the Contour admin interface. It is a ClusterIP service, meaning it is only accessible from within the cluster.

## Envoy Service (LoadBalancer):

- **Type:** LoadBalancer
- **ClusterIP:** 10.100.201.252
- **External-IP:** k8s-projectc-envoy-0e42196471-b91bf5fcd4308ca2.elb.ap-east-1.amazonaws.com
- **Ports:** 80:30693/TCP, 443:31732/TCP
- **Purpose:** The `envoy` service is the external-facing service that exposes the Envoy proxy to the outside world. It is of type LoadBalancer, and in your case, it has an external IP provided by AWS Elastic Load Balancer (ELB). It is accessible externally on ports 80 (HTTP) and 443 (HTTPS).

The separation of `contour` (ClusterIP) and `envoy` (LoadBalancer) services is a common architecture in Ingress controllers like Contour. The `contour` service is used for administrative purposes, while the `envoy` service serves as the entry point for incoming traffic, routing it to the appropriate backend services based on the Ingress rules.


## Basic Comamnds
``
kubectl get namespaces
kubectl get all --namespace projectcontour
kubectl logs -n projectcontour -c envoy envoy-gwjlh
kubectl describe pod envoy-gwjlh -n projectcontour
decribe the service 
kubectl get svc envoy -n projectcontour -o yaml
``

## Contour ingress Controller install

This is te only way i managed to install the ingress controller with an external facing Loadbalancer

``
kubectl apply -f https://projectcontour.io/quickstart/contour.yaml -n projectcontour
kubectl annotate svc envoy -n projectcontour --overwrite service.beta.kubernetes.io/aws-load-balancer-internal=false
``

``
Deploy a test ingress application 

apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-deployment
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      containers:
      - name: nginx
        image: nginx:latest
        ports:
        - containerPort: 80
---
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
spec:
  selector:
    app: nginx
  ports:
    - protocol: TCP
      port: 80
      targetPort: 80
  type: ClusterIP
``

kubectl apply -f nginx-deployment.yaml


## Ingress 

``
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: nginx-ingress
  namespace: projectcontour
  annotations:
    kubernetes.io/ingress.class: "contour"
spec:
  rules:
  - host: nginx.example.com  # Update with your desired host
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: nginx-service
            port:
              number: 80
``

kubectl apply -f nginx-ingress.yaml



## Error

helm repo add bitnami https://charts.bitnami.com/bitnami
helm install kubeapps --namespace kubeapps bitnami/kubeapps \
    --set global.imageRegistry=217273820646.dkr.ecr.us-east-1.amazonaws.com/7762bbba-0563-4863-bb12-2b1dfb26d3c6/cg-1813167126 \
    --set apprepository.image.repository=kubeapps-apprepository-controller \
    --set apprepository.image.tag=1.0.0-0-latest \
    --set apprepository.syncImage.repository=kubeapps-chart-repo \
    --set apprepository.syncImage.tag=1.0.0-0-latest \
    --set chartsvc.image.repository=kubeapps-chartsvc \
    --set chartsvc.image.tag=1.0.0-0-latest \
    --set dashboard.image.repository=kubeapps-dashboard \
    --set dashboard.image.tag=1.0.0-0-latest \
    --set hooks.image.repository=kubectl \
    --set hooks.image.tag=1.0.0-0-latest \
    --set frontend.image.repository=nginx \
    --set frontend.image.tag=1.0.0-0-latest \
    --set postgresql.image.repository=postgresql \
    --set postgresql.image.tag=1.0.0-0-latest